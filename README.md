# ttn-workflows

A repository that stores workflows and things surrounding them (scripts, etc) for the fake app "Toad Town News." Most of the workflows here should be reusable.
Refer to the Workflows section regarding information about each workflow present in this repository (keep in mind that this repository may evolve from time to time, and so documentation regarding workflows may evolve as well. Basically check in from time to time to make sure you're up to date with the workflow you're reading about)

Be sure to check out the associated repositories with caller workflows:
- [ttn-frontend](https://github.com/org-mushroom-kingdom/ttn-frontend/)
- [ttn-backend](https://github.com/org-mushroom-kingdom/ttn-backend/)

TODO MOVE THIS TO g-a-t.yml section AND MAKE IT PRETTY 
** TAKE THIS ALL WITH A HUGE GRAIN OF SALT SINCE I ASKED CHATGPT MOST OF THIS AND HAVEN'T HAD THE CHANCE TO CITE MOST SOURCES **
- During setup, you can give the Github App granular permissions (Note these permissions aren't in the same structure as if you were generating a PAT)
- Installation access tokens inherit these permissions--it's different from PATs in that you can't give it whatever permissions you want. They're specifically tied to the app. If you need to progrmatically generate tokens with different permissions, you probably need to use two different Github Apps
- An installation access token is a token generated by a Github App. They aren't tied to a user and are instead generated on the behalf of the App.
- You can use a Github Actions workflow to generate an installation access token. Then you can use that token right after in the same workflow.
- Installation access tokens are short-lived, they expire 1 hour from their creation. They shouldn't exist on the runner/ on disk. 
- Using installation access tokens helps with dealing with manually-created token expiration timings. With personal tokens, once they expire you have to manually regenerate them and that can REALLY gum things up if you have things like workflows that depend on those tokens to function. It's generally bad practice to have a [personal access]token that never expires, so you can't use that as a workaround. Using installation access tokens deals gracefully with creating a new token and having it expire very quickly--instead of using the same token for a bunch of workflow jobs, one installation access token is generated for each workflow job. Additionally, since it's not tied to a user, it hoists the responsibility off that user.
- It's interesting to note that in the situation of changelog-quality-checks.yml, when using a PAT you pass the PAT in from the caller workflow. That means that a user (me) made a PAT, then messed with the caller workflow repo to configure it as a secret. This directly contrasts with how installation access tokens work: You install the Github App on the reusable workflow repository, and generate the installation access token in that reusable workflow. So in this case the reusable workflow repo is doing all the token work. That works out because if it were the other way around like PAT stuff, you'd have to install the Github App on every caller workflow repository. 

Keeping all that in mind, this 1-22-26 scenario will be very similar to how we got changelog-quality-checks.yml to work in terms of our desired behavior. It's the vector of delivery of that desired behavior that is changing. 

Okay made the app with certain permissions (contents: read, pull request: read, metadata: read)
Made a private token after: A notification tells you to. Literally all I had to do with hit a button and it made it. 
This prompts an download of a PEM file on your local machine.
Then go to user profile --> Github Apps --> Select your app --> Edit --> Install (left sidebar) --> Allows me to pick my user or the org I own --> I pick the org--> I pick ttn-workflows as the repo (as opposed to All repositories)
The repo you want to install the app on needs the private key for the app to function. Copy the value of the downloaded PEM and save it as a secret.
You may also want to save the Github App ID as a organizational or repository variable for easy access. (Almost same process as setting a secret)
Make the reusable workflow. Have workflow_dispatch on there in the beginning to fire off manually. 
Go to the actions/create-github-app-token page to see how to make the steps to generate and then use the token (the token is an output of the step that calls actions/create-github-app-token, meaning you can reference that output in a future step)
Frankenstein those steps for your specific use. Comment them out.
Test the actual logic of the reusable workflow without generating the token at first to prevent headache
Once confirmed basic logic work, comment token steps back in.
Add workflow_call to reusable workflow.
Make caller workflow to call reusable workflow.
See what happens

CHECK THAT APP IS SECURE ENOUGH SO NEFARIOUS PEOPLE AREN'T GOING TO BE WADS

# Workflows

## changelog-quality-check.py

Caller workflows: 
- [org-mushroom-kingdom/ttn-frontend/.github/workflows/sc-changelog-check-exists-and-naming-caller.yml](https://github.com/org-mushroom-kingdom/ttn-frontend/blob/main/.github/workflows/sc-changelog-check-exists-and-naming-caller.yml)
- [org-mushroom-kingdom/ttn-backend/.github/workflows/sc-changelog-check-exists-and-naming-caller.yml]https://github.com/org-mushroom-kingdom/ttn-backend/blob/main/.github/workflows/sc-changelog-check-exists-and-naming-caller.yml

Trigger of the caller workflows: pull_request [open, synchronize]

### Scenario

Note: The code written here is used as a supplement to the Medium article ['Github Actions: Checking Out And Utilizing a Reusable Workflow's Repository'](https://medium.com/devops-dev/github-actions-checking-out-and-utilizing-a-reusable-workflows-repository-992adbe7b3ae).

In this scenario, `ttn-frontend` and `ttn-backend` rely on the reusable workflow `changelog-quality-checks.yml` which checks for a changelog file (referred to hereon as a CHANGELOG file) when a pull request is made from a release branch to the main branch (See **__Trigger** for more details). The logic surrounding the CHANGELOG file is strict and the file must meet certain criteria before merging into the preprod or main branch is allowed (see **__Business Logic__** for details). 

The reusable workflow relies on a script for the brunt of its work. This script is also located in `ttn-workflows`. Since the reusable workflow is in a different repository than the caller workflow's location (either `ttn-frontend` or `ttn-backend`), the script can't be referenced simply by pointing to its path. We must explicitly checkout `ttn-workflows` so the reusable workflow can access the script and perform its logic properly.

### Triggers

workflow_dispatch: This workflow can be triggered manually. TODO SEE MANUAL TESTING?

A reusable workflow that should be called upon by caller workflows when the caller workflow's repository has certain pull request activity (opened, synchronize, or reopened) that is a release branch being merged into the main branch. A release branch will have the word 'release' as a prefix. See more details in caller workflow repos like `ttn-frontend`.

### Business Logic

The following section and subsections explain how the `changelog-quality-check.yml` reusable workflow performs its work. 

#### **CHANGELOG File Quantity Check**

This workflow will assess a pull request's files and ensure there is a singular, properly named CHANGELOG file. 

When assessing the changed files in a pull request, the workflow will assess how many potential CHANGELOG files there are. A potential CHANGELOG file is any file that begins with the substring "CHANGELOG" in this case. In the event the amount of potential CHANGELOG files is NOT 1, the workflow will evaluate this as a failure (even in a scenario where a properly-named CHANGELOG file may be present amongst other potential CHANGELOG files)

#### **Expected CHANGELOG Filename**

When a singular potential CHANGELOG file has been identified, it will be assessed to ensure it has the expected filename. 

A properly named CHANGELOG file meets the following criteria:<br>
- Begins with the text "CHANGELOG"
- Has the repository name in it (known in the script as `release_verison`) in the fashion of `org-mushroom-kingdom/ttn-*` where * is the desired text. This text (known in the script as `ttn_type`) should be after the CHANGELOG prefix and a dash separator (ex. if the repository is `org-mushroom-kingdom/ttn-frontend`, then the text 'frontend' should be present)
- Has the release version in it, after the above mentioned substring and a dash separator. The release version should match the name of the source branch that is being merged into the main/master branch (ex. if the source branch name is 'release/v1.1', the substring 'v1.1' should be present).
- Ends with the extension '.txt'

For example, given the following scenario: 

- <u>Repository</u>: `org-mushroom-kingdom/ttn-frontend` 
- <u>Source Branch (release branch)</u>: `release/v1.1`

The expected CHANGELOG filename would be `CHANGELOG-frontend-v1.1.txt`.

Examples CHANGELOG filenames that would NOT be valid are:
- `CHANGELOGfrontend-v1.1.txt` (lacks a dash between CHANGELOG and the `ttn_type` (frontend))
- `CHANGELOG-ttn-frontend-v1.1.txt` (has 'ttn' in it, when the expected `ttn_type` should be 'frontend')
- `CHANGELOGfrontend-1.1.txt` (has '1.1' in it, when the release_version should be 'v1.1')


#### **Workflow and Script Logic**

This workflow consists of one job `changelog-check` (full name 'Changelog Check (Exists and Naming)'). This workflow relies on a Python script `changelog-quality-check.py` for much of its work. 

When called upon, this workflow will perform the following logic <br>(Note: steps that are triggered by manual testing are not listed. Additionally, the Python script is explained all in one step.)

1. Set various environmental variables that relate to the pull request.
2. Checkout the repository using `actions/checkout` (this will checkout the caller repository)
3. Print (echo) various environmental variables and select other variables
4. Set the expected CHANGELOG filename based on the (caller) repository name and source branch name. (see above subsection **__Expected CHANGELOG Filename__**)
5. Get the changed files of the pull request that triggered the workflow (i.e. the changed files of the pull request in the caller workflow's repo.). This is done via a Github API call. These files will be written to a comma-delimited string (the environmental variable `CHANGED_FILES_STR`).
6. Uses `actions/setup-python` to setup Python in the Github-hosted runner, since a Python script will be called to do some of the work.
7. Checks out the `org-mushroom-kingdom/ttn-workflows` repo. This is needed because the aforemetioned Python script is in the `ttn-workflows` repo. When this workflow is called, it is done within the context of the caller workflow's repository. Thus, we checkout the `ttn-workflows` repository to the `ttn-workflows-repo/` directory in our runner. We can then utilize the Python script via accessing this directory
8. Grant execute permissions to the Python script (via the `ttn-workflows-repo/` directory)
9. Run the Python script (`changelog-quality-check.py`): <br>
      &emsp; We provide the expected CHANGELOG filename and changed file list as arguments. <br>
      &emsp;a. For each changed file (LOOP): <br>
            &emsp;&emsp;- IF it begins with 'CHANGELOG': <br>
                &emsp;&emsp;&emsp;- If true, add it to an array `potential_changelog_files` <br>
                &emsp;&emsp;&emsp;- If false, do nothing <br>
      &emsp;b. After the changed file LOOP has finished, assess the length of `potential_changelog_files`: <br>
            &emsp;&emsp;- IF the length is > 1: <br>
                &emsp;&emsp;&emsp;- Set an output message as the environmental variable `CHANGELOG_MSG` stating only one CHANGELOG file is allowed<br>
                &emsp;&emsp;&emsp;- Print this message<br>
                &emsp;&emsp;&emsp;- Exit with a bad status code<br>
            &emsp;&emsp;- ELSE IF the length is 0: <br>
                &emsp;&emsp;&emsp;- Set an output message as the environmental variable `CHANGELOG_MSG` stating a CHANGELOG file is required. <br>
                &emsp;&emsp;&emsp;- Print this message<br>
                &emsp;&emsp;&emsp;- Exit with a bad status code<br>
            &emsp;&emsp;- ELSE (`potential_changelog_files` is exactly 1 length):<br>
                &emsp;&emsp;&emsp;- IF the file has the expected CHANGELOG name (see above subsection **__Expected CHANGELOG Filename__**): <br>
                    &emsp;&emsp;&emsp;&emsp;- If true:<br>
                        &emsp;&emsp;&emsp;&emsp;&emsp;- Set an output message as the environmental variable `CHANGELOG_MSG` stating the name of the CHANGELOG file is correct. <br>
                        &emsp;&emsp;&emsp;&emsp;&emsp;- Print this message. <br>
                        &emsp;&emsp;&emsp;&emsp;&emsp;- Exit with a passing status code. <br>
                    &emsp;&emsp;&emsp;&emsp;- If false: <br>
                        &emsp;&emsp;&emsp;&emsp;&emsp;- Set an output message as the environmental variable `CHANGELOG_MSG` stating the name of the CHANGELOG file is incorrect, as well as what it should be. <br> 
                        &emsp;&emsp;&emsp;&emsp;&emsp;- Print this message. <br>
                        &emsp;&emsp;&emsp;&emsp;&emsp;- Exit with a bad status code.<br>
10. Use the `CHANGELOG_MSG` environmental variable that was set in step 9 in conjunction with the Github API to put a comment on the PR stating the status of the CHANGELOG file quality checks.
11. Based upon the status code of the Python script, the workflow returns a passing or failing status. This status can be leveraged with a branch protection rule to allow or disallow merging the PR into the target branch. 

### Manual Testing

This workflow has the `workflow_dispatch` trigger, meaning it can be triggered manually. This workflow was manually tested using the Github Actions UI page.

#### **Manual Testing Inputs**

The following inputs are used for manual testing:

| Name | Description | Type | Notes |
|---|---|---|---|
| `exp_changelog_filename_man` | Expected CHANGELOG filename | choice | Options: <br> - 'CHANGELOG_frontend_v1.1.txt' <br> - 'CHANGELOG_backend_v1.2.txt' |
| `pr_num_man` | Manual PR number (changed files) | choice | Options: <br> - '2 - CHANGELOG_frontend_v1.1.txt' <br>- '3 - CHANGELOG_backend_v1.2.txt' <br> - '4 - CHANGELOG_backend_v1.1.txt,CHANGELOG_backend_v1.2.txt' |

The first input `exp_changelog_filename_man` is the name of the expected CHANGELOG filename. 

The other input `pr_num_man` is number points to a real pull request in the `ttn-workflows` repo, followed by the changed in that pull request. This number is used in the Github API call mentioned in the __**Workflow and Script Logic**__ section. Having it be set up this way allows us to test the workflow more organically (versus doing something like setting the `CHANGED_FILES_STR` to the value of some input). You may ask why didn't I be fancy and try to take pull requests from other repos and the reason I didn't is because this way is simpler and I also didn't even think about that until I wrote this sentence.

The mixing and matching of these inputs allow you to produce the following scenarios:

1. (Happy Path) The CHANGELOG file has the expected name because its name properly corresponds with the source (release) branch name and it is the only CHANGELOG file present in the "pull request"
2. The CHANGELOG file is NOT properly named, because its name does NOT properly correspond with the source (release) branch name. However, it is the only CHANGELOG file present in the "pull request".
3. There are too many potential CHANGELOG files.
4. There are no CHANGELOG files. 

Scenario 1 is the most easily tested since the first option in each input match up with each other. To test Scenario 1, simply just hit the __Run test__ button without changing any input. You could also test Scenario 1 by using the second option of each input.

Scenario 2 is tested by having the inputs be misaligned with each other (the `pr_num_man` input having exactly 1 CHANGELOG file in it, so the first or second option). One CHANGELOG file exists in the changed file list, but does not match the expected CHANGELOG name.

Scenario 3 is tested by using the `pr_num_man` option '4 - CHANGELOG_backend_v1.1.txt,CHANGELOG_backend_v1.2.txt' which corresponds to a pull request with more than one CHANGELOG file in it. 

Scenario 4 is tested by using the `pr_num_man` option '5 - dummy-file.txt' which corresponds to a pull request that lacks a CHANGELOG file.

## get-article-titles.yml

TODO LINKS

<ins>Caller workflows</ins>: `org-mushroom-kingdom/ttn-frontend/.github/workflows/get-article-titles.yml` 
<ins>Trigger of the caller workflow</ins>: `workflow_dispatch` (Manually triggered)

### Scenario

TODO ARTICLE LINK ONCE DONE!!! The code here is used as a supplement to the Medium article TODO CONFIRM TITLE 'Creating and Using a Basic Github App for Token Management in Workflows: A Guide'. Refer to that article for additional context and details.

In this scenario, developers are working on integrating installation access tokens to move away from personal access token management. Devs have complained about having to make their own PATs and having to remember to refresh them when they expire (among other reasons), so a solution where tokens could be generated programmatically and not tied to a user would be an ideal situation. 

The developers want to generate and use an installation access token to access a file on the reusable workflow's repository (`ttn-workflows`). One dev creates a sample .txt file with article titles they have to work with at some point and store this in the `ttn-workflows` repository. The goal is to just use Bash `cat` to print the contents of that file--seeing that means the installation access token was made successfully and able to be used to checkout the repository. 

Note: Since a caller workflow in a different repository triggers the reusable workflow, and there is a file present in the reusable workflow's repository we want access to, we need to checkout the reusable workflow's repository. This requires a token, and `GITHUB_TOKEN` will not suffice in this scenario because `GITHUB_TOKEN` permissions are restricted to the repository of the workflow that was initially triggered (the caller workflow in this case).  

A Github App is a good way to approach this issue, due in no small part to `actions/create-github-app-token`. That action creates an installation access token, a short-lived non-personal token that inherits the permissions the Github App has been granted. The term "non-personal" in this sense means that the token is not tied to a user like a PAT or fine-grained access token; instead, it is tied to the Github App itself. The installation access token will have the same permissions that were granted to the Github App when it was created.

This scenario utilizes a Github App that was created on a personal account (vs. an organization account). The owner of the App is thus a user, not an organization. The App is installed on `ttn-workflows`. Details about Github App creation and installation can be found in the article. TODO PERMISSIONS (contents: read, pull request: read, metadata: read)

As an aside, you don't need to create a Github App for each caller workflow for this particular scenario. Instead, you install the Github App on the repository you intend to use it on, which would be `ttn-workflows` in our case. It's sort of the opposite of how the CHANGELOG quality check logic works--for that logic, we passed a token in from the caller workflow's repo. In this scenario, our token-related activity is on the reusable workflow's repo. Note that you still have to pass a secret (the Github App's private key) from the caller workflow to the reusable workflow. Generally, it is acceptable for the same private key to be used for multiple repositories within the same organization. 

### Triggers

TODO REWORK

A reusable workflow that should be called upon by caller workflows when the caller workflow is manually triggered via the workflow_dispatch event. TODO See more details in caller workflow repos like `ttn-frontend`. 

### **Workflow Logic**

The following section and subsections explain how the `get-article-titles.yml` reusable workflow performs its work. 

1. Instantiates the environmental variable `REPO_PATH` to "." (the current working directory). 
2. Checks out the repository that triggered/called upon this workflow (will be `ttn-workflows` if manually tested, `ttn-frontend` if called)
3. For manual runs ONLY, sets the APP_ID environmental variable to a `ttn-workflows` repository variable
   - Note: See the code for details. This step essentially does nothing unless you do some future code edits.
4. Generate the installation access token via the Github App:
   - The app-id is from a variable set in the caller workflow's repository. 
     Note: It is more traditional to pass this variable as an input in the call to the reusable workflow, but I wanted to see if the `vars` context of the caller repository could be properly accessed in this matter.
   - The private-key is passed in from the caller workflow
   - The owner is the repository's owner
   - The repositories lists the repository to grant access to (`ttn-workflows`)
   
   The App has __Contents:Read-only__ and __Pull requests:Read-only__ permissions. These are granted to the installation access token, meaning it can read files within the ttn-workflows repository.
5. Checkout the `ttn-workflows` repository under the directory specified by `path` (`ttn-workflows-repo`) using the installation access token generated from Step 4. (This step is skipped if manually testing)
6. Set the environmental variable `REPO_PATH` to  `ttn-workflows-repo` (This step is skipped if manually testing)
7. Use `cat` to print the contents of the `article-titles-1–22–26.txt` file. 

### Manual Testing

To properly test this scenario, trigger the caller workflow `sc-changelog-check-exists-and-naming-caller.yml` in `ttn-frontend`.

Testing the reusable workflow on its own is a more complex task due to the way this code was written. For simplicity in the corresponding article that goes along with this code, I didn't want to have to add and then subsequently explain the intracacies of the logic that would be present when it comes to assessing the repository that triggers the reusable workflow in the 'Generate GitHub App token' step. The article is more focused on caller/reusable workflow relationships and how they relate to a use case for installation access tokens rather than testing flexibility. However, there are steps one can take independently to be able to test the reusable workflow via a `workflow_dispatch` event in its own repository: see the comments at the top of the code for details.

