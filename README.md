# ttn-workflows

A repository that stores workflows and things surrounding them (scripts, etc) for the fake app "Toad Town News." Most of the workflows here should be reusable.
Refer to the Workflows section regarding information about each workflow present in this repository (keep in mind that this repository may evolve from time to time, and so documentation regarding workflows will evolve as well. Basically check in from time to time to make sure you're up to date with the workflow you're reading about)
1-3-26: At the time of writing, this only has one reusable workflow `changelog-quality-checks.yml` used as a supplement to the Medium article 'Github Actions: Checking Out And Utilizing a Reusable Workflow's Repository' TODO LINK. However, it may store more reusable workflows for testing purposes or as additional supplemental material for future articles.

1-22-26: And guess what we're going to have another reusable workflow soon that will also checkout this repository and access a script because I need to see how all this Github App stuff works in regards to generating installation access tokens. I'm gonna restructure this part but basically:

** TAKE THIS ALL WITH A HUGE GRAIN OF SALT SINCE I ASKED CHATGPT MOST OF THIS AND HAVEN'T HAD THE CHANCE TO CITE MOST SOURCES **
- You can create a Github App on your personal account 
- During setup, you can give the Github App granular permissions (Note these permissions aren't in the same structure as if you were generating a PAT)
- Installation access tokens inherit these permissions--it's different from PATs in that you can't give it whatever permissions you want. They're specifically tied to the app. If you need to progrmatically generate tokens with different permissions, you probably need to use two different Github Apps
- An installation access token is a token generated by a Github App. They aren't tied to a user and are instead generated on the behalf of the App.
- You can use a Github Actions workflow to generate an installation access token. Then you can use that token right after in the same workflow.
- Installation access tokens are short-lived, they expire 1 hour from their creation. They shouldn't exist on the runner/ on disk. 
- Using installation access tokens helps with dealing with manually-created token expiration timings. With personal tokens, once they expire you have to manually regenerate them and that can REALLY gum things up if you have things like workflows that depend on those tokens to function. It's generally bad practice to have a [personal access]token that never expires, so you can't use that as a workaround. Using installation access tokens deals gracefully with creating a new token and having it expire very quickly--instead of using the same token for a bunch of workflow jobs, one installation access token is generated for each workflow job. Additionally, since it's not tied to a user, it hoists the responsibility off that user.
- It's interesting to note that in the situation of changelog-quality-checks.yml, when using a PAT you pass the PAT in from the caller workflow. That means that a user (me) made a PAT, then messed with the caller workflow repo to configure it as a secret. This directly contrasts with how installation access tokens work: You install the Github App on the reusable workflow repository, and generate the installation access token in that reusable workflow. So in this case the reusable workflow repo is doing all the token work. That works out because if it were the other way around like PAT stuff, you'd have to install the Github App on every caller workflow repository. 

Keeping all that in mind, this 1-22-26 scenario will be very similar to how we got changelog-quality-checks.yml to work in terms of our desired behavior. It's the vector of delivery of that desired behavior that is changing. 

Look at me type in such a way that I assume so many people are going to read this, ha ha!

Okay made the app with certain permissions (contents: read, pull request: read, metadata: read)
Made a private token after: A notification tells you to. Literally all I had to do with hit a button and it made it. 
This prompts an download of a PEM file on your local machine.
Then go to user profile --> Github Apps --> Select your app --> Edit --> Install (left sidebar) --> Allows me to pick my user or the org I own --> I pick the org--> I pick ttn-workflows as the repo (as opposed to All repositories)
The repo you want to install the app on needs the private key for the app to function. Copy the value of the downloaded PEM and save it as a secret.
You may also want to save the Github App ID as a organizational or repository variable for easy access. (Almost same process as setting a secret)
Make the reusable workflow. Have workflow_dispatch on there in the beginning to fire off manually. 
Go to the actions/create-github-app-token page to see how to make the steps to generate and then use the token (the token is an output of the step that calls actions/create-github-app-token, meaning you can reference that output in a future step)
Frankenstein those steps for your specific use. Comment them out.
Test the actual logic of the reusable workflow without generating the token at first to prevent headache
Once confirmed basic logic work, comment token steps back in.
Add workflow_call to reusable workflow.
Make caller workflow to call reusable workflow.
See what happens

CHECK THAT APP IS SECURE ENOUGH SO NEFARIOUS PEOPLE AREN'T GOING TO BE WADS

# Workflows

## changelog-quality-check.py

### Trigger

A reusable workflow that should be called upon by caller workflows when the caller workflow's repository has certain pull request activity (opened, synchronize, or reopened) that is a release branch being merged into the main branch. A release branch will have the word 'release' as a prefix. See more details in caller workflow repos like `ttn-frontend`.

### Business Logic

The following section and subsections explain how the `changelog-quality-check.py` reusable workflow performs its work. 


#### **CHANGELOG File Quantity Check**

This workflow will assess a pull request's files and ensure there is a singular, properly named CHANGELOG file. 

When assessing the changed files in a pull request, the workflow will assess how many potential CHANGELOG files there are. A potential CHANGELOG file is any file that begins with the substring "CHANGELOG" in this case. In the event the amount of potential CHANGELOG files is NOT 1, the workflow will evaluate this as a failure (even in a scenario where a properly-named CHANGELOG file may be present amongst other potential CHANGELOG files)

#### **Expected CHANGELOG Filename**

When a singular potential CHANGELOG file has been identified, it will be assessed to ensure it has the expected filename. 

A properly named CHANGELOG file meets the following criteria:<br>
- Begins with the text "CHANGELOG"
- Has the repository name in it (known in the script as `release_verison`) in the fashion of `org-mushroom-kingdom/ttn-*` where * is the desired text. This text (known in the script as `ttn_type`) should be after the CHANGELOG prefix and a dash separator (ex. if the repository is `org-mushroom-kingdom/ttn-frontend`, then the text 'frontend' should be present)
- Has the release version in it, after the above mentioned substring and a dash separator. The release version should match the name of the source branch that is being merged into the main/master branch (ex. if the source branch name is 'release/v1.1', the substring 'v1.1' should be present).
- Ends with the extension ".txt"

For example, given the following scenario: 

- <u>Repository</u>: `org-mushroom-kingdom/ttn-frontend` 
- <u>Source Branch (release branch)</u>: `release/v1.1`

The expected CHANGELOG filename would be `CHANGELOG-frontend-v1.1.txt`.

Examples CHANGELOG filenames that would NOT be valid are:
- `CHANGELOGfrontend-v1.1.txt` (lacks a dash between CHANGELOG and the `ttn_type` (frontend))
- `CHANGELOG-ttn-frontend-v1.1.txt` (has 'ttn' in it, when the expected `ttn_type` should be 'frontend')
- `CHANGELOGfrontend-1.1.txt` (has '1.1' in it, when the release_version should be 'v1.1')


#### **Workflow and Script Logic**

This workflow consists of one job `changelog-check` (full name 'Changelog Check (Exists and Naming)'). This workflow relies on a Python script for much of its work. 

When called upon, this workflow will perform the following logic <br>(Note: steps that are triggered by manual testing are not listed. Additionally, the Python script is explained all in one step.)

1. Set various environmental variables that relate to the pull request.
2. Checkout the repository using `actions/checkout` (this will checkout the caller repository)
3. Print (echo) various environmental variables and select other variables
4. Set the expected CHANGELOG filename based on the (caller) repository name and source branch name. (see above subsection **__Expected CHANGELOG Filename__**)
5. Get the changed files of the pull request that triggered the workflow (i.e. the changed files of the pull request in the caller workflow's repo.). This is done via a Github API call. These files will be written to a comma-delimited string (the environmental variable `CHANGED_FILES_STR`).
6. Uses `actions/setup-python` to setup Python in the Github-hosted runner, since a Python script will be called to do some of the work.
7. Checks out the `org-mushroom-kingdom/ttn-workflows` repo. This is needed because the aforemetioned Python script is in the `ttn-workflows` repo. When this workflow is called, it is done within the context of the caller workflow's repository. Thus, we checkout the `ttn-workflows` repository to the `ttn-workflows-repo/` directory in our runner. We can then utilize the Python script via accessing this directory
8. Grant execute permissions to the Python script (via the `ttn-workflows-repo/` directory)
9. Run the Python script: <br>
      &emsp; We provide the expected CHANGELOG filename and changed file list as arguments. <br>
      &emsp;a. For each changed file (LOOP): <br>
            &emsp;&emsp;- IF it begins with 'CHANGELOG': <br>
                &emsp;&emsp;&emsp;- If true, add it to an array `potential_changelog_files` <br>
                &emsp;&emsp;&emsp;- If false, do nothing <br>
      &emsp;b. After the changed file LOOP has finished, assess the length of `potential_changelog_files`: <br>
            &emsp;&emsp;- IF the length is > 1: <br>
                &emsp;&emsp;&emsp;- Set an output message as the environmental variable `CHANGELOG_MSG` stating only one CHANGELOG file is allowed<br>
                &emsp;&emsp;&emsp;- Print this message<br>
                &emsp;&emsp;&emsp;- Exit with a bad status code<br>
            &emsp;&emsp;- ELSE IF the length is 0: <br>
                &emsp;&emsp;&emsp;- Set an output message as the environmental variable `CHANGELOG_MSG` stating a CHANGELOG file is required. <br>
                &emsp;&emsp;&emsp;- Print this message<br>
                &emsp;&emsp;&emsp;- Exit with a bad status code<br>
            &emsp;&emsp;- ELSE (`potential_changelog_files` is exactly 1 length):<br>
                &emsp;&emsp;&emsp;- IF the file has the expected CHANGELOG name (see above subsection **__Expected CHANGELOG Filename__**): <br>
                    &emsp;&emsp;&emsp;&emsp;- If true:<br>
                        &emsp;&emsp;&emsp;&emsp;&emsp;- Set an output message as the environmental variable `CHANGELOG_MSG` stating the name of the CHANGELOG file is correct. <br>
                        &emsp;&emsp;&emsp;&emsp;&emsp;- Print this message. <br>
                        &emsp;&emsp;&emsp;&emsp;&emsp;- Exit with a passing status code. <br>
                    &emsp;&emsp;&emsp;&emsp;- If false: <br>
                        &emsp;&emsp;&emsp;&emsp;&emsp;- Set an output message as the environmental variable `CHANGELOG_MSG` stating the name of the CHANGELOG file is incorrect, as well as what it should be. <br> 
                        &emsp;&emsp;&emsp;&emsp;&emsp;- Print this message. <br>
                        &emsp;&emsp;&emsp;&emsp;&emsp;- Exit with a bad status code.<br>
10. Use the `CHANGELOG_MSG` environmental variable that was set in step 9 in conjunction with the Github API to put a comment on the PR stating the status of the CHANGELOG file quality checks.
11. Based upon the status code of the Python script, the workflow returns a passing or failing status. This status can be leveraged with a branch protection rule to allow or disallow merging the PR into the target branch. 

### Manual Testing

This workflow has the `workflow_dispatch` trigger, meaning it can be triggered manually. This workflow was manually tested using the Github Actions UI page.

#### **Inputs**

The following inputs are used for manual testing:

| Name | Description | Type | Notes |
|---|---|---|---|
| `exp_changelog_filename_man` | Expected CHANGELOG filename | choice | Options: <br> - 'CHANGELOG_frontend_v1.1.txt' <br> - 'CHANGELOG_backend_v1.2.txt' |
| `pr_num_man` | Manual PR number (changed files) | choice | Options: <br> - '2 - CHANGELOG_frontend_v1.1.txt' <br>- '3 - CHANGELOG_backend_v1.2.txt' <br> - '4 - CHANGELOG_backend_v1.1.txt,CHANGELOG_backend_v1.2.txt' |

The first input `exp_changelog_filename_man` is the name of the expected CHANGELOG filename. 

The other input `pr_num_man` is what the changed files might be in hypothetical pull request (which we can refer to as "pull request"). There is a number before the list of changed files. This is because that number points to a real pull request in the `ttn-workflows` repo; that number is used in the Github API call mentioned in the __**Workflow and Script Logic**__ section. Having it be set up this way allows us to test the workflow more organically (versus doing something like setting the `CHANGED_FILES_STR` to the value of some input). You may ask why didn't I be fancy and try to take pull requests from other repos and the reason I didn't is because this way is simpler and I also didn't even think about that until I wrote this sentence.

The mixing and matching of these inputs allow you to produce the following scenarios:

1. (Happy Path) The CHANGELOG file has the expected name because its name properly corresponds with the source (release) branch name and it is the only CHANGELOG file present in the "pull request"
2. The CHANGELOG file is NOT properly named, because its name does NOT properly correspond with the source (release) branch name. However, it is the only CHANGELOG file present in the "pull request".
3. There are too many potential CHANGELOG files.
4. There are no CHANGELOG files. 

Scenario 1 is the most easily tested since the first option in each input match up with each other. To test Scenario 1, simply just hit the Run test button without changing any input. You could also test Scenario 1 by using the second option of each input.

Scenario 2 is tested by having the inputs be misaligned with each other (the `pr_num_man` input having exactly 1 CHANGELOG file in it, so the first or second option). One CHANGELOG file exists in the changed file list, but does not match the expected CHANGELOG name.

Scenario 3 is tested by using the `pr_num_man` option '4 - CHANGELOG_backend_v1.1.txt,CHANGELOG_backend_v1.2.txt' which corresponds to a pull request with more than one CHANGELOG file in it. 

Scenario 4 is tested by using the `pr_num_man` option '5 - dummy-file.txt' which corresponds to a pull request that lacks a CHANGELOG file.

## get-article-titles.yml

Caller workflows: org-mushroom-kingdom/ttn-frontend/.github/workflows/get-article-titles.yml 

### Scenario

TODO
In this scenario, article titles are formulated by a person and then stored in `ttn-workflows` temporarily for whatever reason (maybe a database went down or there's some issue or an issue with the backend, whatever). The frontend also needs access to these article titles for a poll they are displaying on the home page where readers can vote for the article they want to hear most about in the next issue. (As an aside: I mean, geez, this is the first thing that came in my head. In a real life scenario, there'd be several reasons why a frontend repository might have to access something in a reusable workflow repository. I wanted something similar but not exact to how the CHANGELOG file scenario worked, but couldn't think of anything realistic so here we are.)

get-article-titles.yml will check out the reusable workflow's own repo (this repo, `ttn-workflows`) to get access to article-titles-1-22-26.txt

Since a caller workflow in a different repository triggers the reusable workflow, and there is a file present in the reusable workflow's repository we want access to, we need to checkout the reusable workflow's repository. `org-mushroom-kingdom` is trying to get up to speed with token management. Devs have complained about having to make their own PATs and having to remember to refresh them when they expire dates, so a solution where tokens could be generated programmatically and not tied to a user would be an ideal situation.

A Github App is a good way to approach this issue, due in no small part to `actions/create-github-app-token`. That action creates an installation access token, a short-lived non-personal token that inherits the permissions the Github App has been granted. The term "non-personal" in this sense means that the token is not tied to a user like a PAT or fine-grained access token; instead, it is tied to the Github App itself. The installation access token will have the same permissions that were granted to the Github App when it was created

As an aside, you don't need to create a Github App for each caller workflow for this particular scenario. Instead, you install the Github App on the repository you intend to use it on, which would be ttn-workflows in our case. It's sort of the opposite of how the CHANGELOG quality check logic works--for that logic, we passed a token in from the caller workflow's repo. In this scenario, our token-related activity is on the reusable workflow's repo. 

### Trigger

A reusable workflow that should be called upon by caller workflows when the caller workflow is manually triggered via the workflow_dispatch event. TODO See more details in caller workflow repos like `ttn-frontend`. 

### Business Logic

The following section and subsections explain how the `get-article-titles.yml` reusable workflow performs its work. 
