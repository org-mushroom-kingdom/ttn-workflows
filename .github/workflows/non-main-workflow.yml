name: Non-main workflow

# Scenario: Say we want to do a basic server connectivity test before deploying to them. Toad Town News is strict with merges to main during certain time periods; this is one of those times.
# In other words, the workflow needs to be tested without being merged to the default branch (main)
# There are multiple ways to do this, thus the variety of triggers.

# WITH THAT IN MIND, treat this file as if it was NOT merged to main (I'm merging it to main to keep things tidy). 
# Treat the comments in the same way. (I've tried to use the phrase "When the workflow isn't merged to main" diligently)
# The branch this workflow was originally tested on was feature/matt-test-workflow-without-main-merge
# TODO ELABORATE?

# The business logic of this workflow is thus:
# For each server in /deploys/server-list.csv: Make GET request to server, print out the server and HTTP status code for each server in a .csv list 
# If HTTP code is 200, print out in green. If HTTP code is NOT 200, print that out in red.
# Such logic can later be elaborated upon to make programmatic deploy decisions (ex. if server X is down, continue with deploy. If server Y is down, don't) 
on:
  
  push:
    # When the workflow isn't merged to main, you don't have to specify the feature branch the workflow is on.
    # This is because Github evaluates only evalutes workflow files that exist in the branch receiving the push. (See dev.solve)
    # You can still include branches: though if you want to make it more explicit or serve as a reminder.
    branches: [feature/matt-test-workflow-without-main-merge]
    # When the workflow isn't merged to main, if you want to fire it whenever a push occurs, DON'T use the below line
    # The paths: key is for fine-tuning. For this file, we limit the workflow to fire under a push ONLY when that push includes a change to './github/workflows/non-main-workflow.yml'
    paths: 
      - './github/workflows/non-main-workflow.yml'

  # The default types for pull_request are open, synchronize, and reopen
  # When the workflow isn't merged to main, to get the workflow to fire using this trigger you have to first open a pull request (PR) 
  # with the target (base) branch being the feature branch you have the workflow on   
  # The initial creation of the PR is the "open" trigger and thus fires off the workflow
  # To perform further firings of the workflow with a vanilla pull_request trigger, you can:
  # Open another PR with the target branch being the feature branch you have the workflow on ("open" trigger)
  # While the PR is open, make a commit to the source branch of the PR ("synchronize" trigger) *This is the easiest way.
  # Close and reopen the PR ("reopen" trigger)
  pull_request:
    # When the workflow isn't merged to main, you don't have to specify the feature branch the workflow is on.
    # TODO CONFIRM: This is because the pull_request trigger only evalutes workflow files that exist in the target (base) branch of the PR
    # You can still include branches: though if you want to make it more explicit or serve as a reminder.
    # TODO: paths: test with and without
    # TODO paths: CHANGED FILES BLABLABLA


  # TODO API call
  # TODO Github CLI call
  # TODO mention inputs can be used
  # TODO mention if::::: github_event == 'workflow_dispatch' to avoid runtime errors for non-w_d triggers 
  workflow_dispatch:
    inputs:
      example-string-input:
        description: "If using this input, value put here will be printed if event is workflow_dispatch."
        required: false
        type: string
        default: "You didn't put anything :("

  # TODO God, why would you do this to yourself
  # TODO Need caller workflow somewhere
  workflow_call:

  # TODO SEE IF THIS EVEN WORKS
  # TODO MAKE PAT w workflow OR public_repo? permission to use in Postman
  # TODO define event type
  repository_dispatch:

jobs:
  non-main-job:
    name: "Non-main job"
    runs-on: ubuntu-latest
    steps:
        
        - name: Checkout repo
          uses: actions/checkout@v4

        - name: Ping target destination
          run: |
            http_status_code=$(curl -s -o /dev/null -w "%{http_code}" https://bored-api.appbrewery.com/randomaaaaaaaaaaaaaaaaaaaa)
            echo "http_status_code = $http_status_code"

        - name: Grant 'runner' user exec permissions
          run: chmod u+x ./scripts/server-checks.sh

        - name: Perform server checks
          run: ./scripts/server-checks.sh