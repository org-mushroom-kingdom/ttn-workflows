name: Non-main workflow

# Scenario: Say we want to do a basic server connectivity test before deploying to them. Toad Town News is strict with merges to main during certain time periods; this is one of those times.
# In other words, the workflow needs to be tested without being merged to the default branch (main)
# There are multiple ways to do this, thus the variety of triggers.

# WITH THAT IN MIND, treat this file as if it was NOT merged to main (I'm merging it to main to keep things tidy). 
# Treat the comments in the same way. (I've tried to use the phrase "When the workflow isn't merged to main" diligently)
# The branch this workflow was originally tested on was feature/matt-test-workflow-without-main-merge
# TODO ELABORATE?

# The business logic of this workflow is thus:
# Via calling a script (TODO NAME):
# For each server in /deploys/server-list.csv: Make GET request to server, print out the server and HTTP status code for each server in a .csv list 
# If HTTP code is 200, print out in green. If HTTP code is NOT 200, print that out in red.
# Such logic can later be elaborated upon to make programmatic deploy decisions (ex. if server X is down, continue with deploy. If server Y is down, don't) 
on:
  
  push:
    # When the workflow isn't merged to main, you don't have to specify the feature branch the workflow is on.
    # This is because Github evaluates only evalutes workflow files that exist in the branch receiving the push. (See dev.solve)
    # You can still include branches: though if you want to make it more explicit or serve as a reminder.
    branches: [feature/matt-test-workflow-without-main-merge]
    # When the workflow isn't merged to main, if you want to fire it whenever a push occurs, DON'T use the below line
    # The paths: key is for fine-tuning. For this file, we limit the workflow to fire under a push ONLY when that push includes a change to './github/workflows/non-main-workflow.yml'
    paths: 
      - './github/workflows/non-main-workflow.yml'

  # The default types for pull_request are open, synchronize, and reopen
  # When the workflow isn't merged to main, to get the workflow to fire using this trigger you have to first open a pull request (PR) 
  # with the target (base) branch being the feature branch you have the workflow on   
  # The initial creation of the PR is the "open" trigger and thus fires off the workflow
  # To perform further firings of the workflow with a vanilla pull_request trigger, you can:
  # Open another PR with the target branch being the feature branch you have the workflow on ("open" trigger)
  # While the PR is open, make a commit to the source branch of the PR ("synchronize" trigger) *This is the easiest way.
  # Close and reopen the PR ("reopen" trigger)
  pull_request:
    # When the workflow isn't merged to main, you don't have to specify the feature branch the workflow is on.
    # TODO CONFIRM: This is because the pull_request trigger only evalutes workflow files that exist in the target (base) branch of the PR
    # You can still include branches: though if you want to make it more explicit or serve as a reminder.
    # TODO: paths: test with and without
    # TODO paths: CHANGED FILES BLABLABLA


  # TODO API call --> TODO MAKE CALL EXAMPLE IN .TXT , .JSON OR SOMETHING
  # TODO Github CLI call --> TODO put it somewhere
  # TODO mention inputs can be used
  # TODO mention if::::: github_event == 'workflow_dispatch' to avoid runtime errors for non-w_d triggers 
  workflow_dispatch:
    inputs:
    # Just an example input  TODO DELETE?
      example-string-input:
        description: "If using this input, value put here will be printed if event is workflow_dispatch."
        required: false
        type: string
        default: "You didn't put anything :("
      # Use this in API calls to determine how workflow_dispatch was triggered. 
      # (This isn't strictly required, but if the workflow gets merged in to the default branch and you want to use the UI to run it AND API calls, 
      # this helps determine the nature of the workflow_dispatch trigger.)  
      triggered-by-api:
        description: "Helps determine if called by API"
        required: true
        type: boolean
        default: false
      # For this particular scenario, we're testing several different ways to trigger a workflow that hasnt't been merged into main
      # Thus, we often may care more about the method used to call and not always desire to execute the script.
      perform-server-check:
        description: "Do the server check"
        required: true
        type: boolean
        default: true

  # TODO God, why would you do this to yourself
  # TODO Need caller workflow somewhere
  workflow_call:

  # TODO SEE IF THIS EVEN WORKS
  # TODO MAKE PAT w workflow OR public_repo? permission to use in Postman
  # TODO define event type
  repository_dispatch:

jobs:
  non-main-job:
    name: "Non-main job"
    runs-on: ubuntu-latest
    env:
      YELLOW: "\e[0;34m"
      ENDCOLOR: '\033[0m'
    steps:
        
        - name: Checkout repo
          uses: actions/checkout@v4

        - name: Echo workflow trigger
          run: echo-e "This workflow was triggered by $YELLOW ${{ github.event_name }} $ENDCOLOR"

        - name: "workflow_dispatch: Read inputs"
          if: github.event_name == 'workflow_dispatch'
          run: |
            echo "inputs.example-string-input: ${{ inputs.example-string-input }}"
            echo "inputs.triggered-by-api: ${{ inputs.triggered-by-api }}"
            echo "inputs.perform-server-check: ${{ inputs.perform-server-check }}"

        - name: Grant 'runner' user exec permissions
          run: chmod u+x ./scripts/server-checks.sh

        - name: Perform server checks
          if: inputs.perform-server-check
          run: ./scripts/server-checks.sh
